\chapter{Algoritmi}
\label{chapter:theoretical-background}
In questo capitolo affronteremo gli algoritmi alla base delle
implementazioni da un punto di vista teorico. Vedremo la tecnica di
visita del grafo che abbiamo adottato e una panoramica degli algoritmi
per il calcolo delle componenti fortemente connesse.

\section{Visitare un grafo}

La ricerca (o visita) di un grafo \`e una procedura che rivela molte
informazioni sulla sua struttura e molte implementazioni richiedono
tempo lineare.

Prima di descrivere in particolare la ricerca oggetto di questa
sezione, diamo alcune definizioni utili nel seguito e descrizione del
problema pi\`u generico, ovvero di cosa significa visitare un grafo.

\subsection{Alcune definizioni}
\label{subsection:some-definitions}
In questa sezione riportiamo per completezza alcune definizioni che
saranno utilizzate nel resto del capitolo.
\\\\
Un grafo $G$ \`e una coppia $(V, E)$ dove $V$ \`e un insieme di
vertici ed $E$ \`e un insieme di archi. Pi\`u precisamente $E$ \`e una
relazione binaria, che possiamo indicare con il simbolo $\rightarrow$,
tale che $\rightarrow \subset V \times V$. 

Un grafo $G = (V, E)$ si dice \emph{non orientato} se $\rightarrow$
\`e una relazione simmetrica. Altrimenti, se $\rightarrow$ non \`e
simmetrica, il grafo si dice \emph{orientato}.

Sia $G = (V, E)$ un grafo. Un cammino da un vertice $v_{i}$ ad un
vertice $v_{j}$ \`e una sequenza di vertici $\{v_{i}, v_{i+1}, \cdots,
v_{j-1}, v_{j}\}$ tali che $(v_{i},v_{i+1}) \in \rightarrow \wedge
(v_{i+1}, \cdots) \in \rightarrow \wedge \cdots \wedge (\cdots,
v_{j-1}) \in \rightarrow \wedge (v_{j-1}, v_{j}) \in
\rightarrow$. Tale cammino lo indicheremo con la scrittura $v_{i}
\rightarrow^{*} v_{j}$. Nel caso di un grafo \emph{non orientato} lo
stesso cammino lo possiamo scrivere $v_{i} --^{*} v_{j}$

Un cammino $\pi = v_{i} \rightarrow^{*} v_{i}$ \`e chiamato una
cammino \emph{chiuso}. In particolare, un cammino \emph{chiuso} \`e un
\emph{ciclo} quando tutti gli archi che lo compongono sono distinti e
l'unico vertice che appare esattamente due volte in $\pi$ \`e
$v_{i}$. Due cicli che sono permutazioni l'uno dell'altro si
considerano indistinguibili e, pertanto, si considerano essere lo
stesso ciclo.

Un grafo \emph{non orientato} \`e \emph{connesso} se $\forall (v, w)
\exists \pi: \pi = v --^{*} w$. Un grafo \emph{orientato} \`e
\emph{connesso} se $\forall (v, w) \exists \pi: \pi = v
\rightarrow^{*} w$.

Un \emph{grafo orientato} $T$ \`e un albero se valgono le seguenti
propriet\`a:
\begin{itemize}
\item la versione di $T$ \emph{non orientata} \`e connessa
\item esiste esattamente un vertice $v$ tale che $\not \exists (w, v),
  \forall w$. Il vertice $v$ viene chiamato \emph{root} di $T$
\item tutti i vertici distinti dal vertice \emph{root} hanno
  esattamente un arco entrante, ovvero $\forall w \not = root(T),
  \exists!r: (r, w) \in \rightarrow$
\end{itemize}

\subsection{Il concetto di visita}
Sia $G$ il grafo che vogliamo visitare. Inizialmente tutti i vertici
che compongono il grafo sono sconosciuti, nessuno di essi \`e stato
\emph{esplorato}. Iniziamo da un vertice e seguiamo uno dei suoi
archi, che porter\`a ad un nuovo vertice. Continuiamo ad applicare
questa tecnica: quando arriviamo ad un vertice selezioniamo un arco
non ancora percorso, uscente da vertici gi\`a conosciuti. Percorrendo
l'arco che volta volta viene selezionato, si arriva in un vertice che
possiamo aver gi\`a visitato oppure no. Quando non \`e possibile
selezionare nessun arco non ancora percorso uscente da vertici gi\`a
visitati, allora si seleziona un vertice non ancora selezionato e si
riapplica la tecnica descritta precedentemente.

Come si capisce dal paragrafo precedente, la visita mira ad
identificare un insieme di vertici del grafo a partire da un vertice
dato in cui la visita ha inizio.

\subsection{Visita in profondit\`a}
Nella precedente sezione abbiamo dato l'idea alla base di una
visita. Vi sono molte strategie che differenziano una visita
dall'altra, ognuna caratterizzata dalla modalit\`a con cui si sceglie
il prossimo arco da percorrere.

La ricerca \emph{visita in profondit\`a} \`e caratterizzata dalla
seguente strategia: \emph{nella selezione del prossimo arco da
  percorrere, scegliere un arco uscente non ancora percorso dal
  vertice pi\`u recentemente esplorato}.

L'insieme dei vertici \emph{pi\`u recentemente esplorati} pu\`o essere
mantenuto in uno \emph{pila}.

Per capire meglio il pattern di questa tecnica supponiamo di iniziare
la visita dal vertice $v$. Prima $v$ viene visitato, poi il suo primo
vicino $v_{1}$ viene scelto e si percorre l'arco $(v, v_{1})$. Adesso
$v_{1}$ viene visitato e si riapplica lo stesso metodo al vicinato di
$v_{1}$. Solo quando tutti i vertici nel vicinato di $v_{1}$ sono
visitati \`e possibile continuare ad esplorare il secondo vicino
$v_{2}$ di $v$ (\`e possibile che $v_{2}$ venga visitato durante
l'esplorazione di $v_{1}$, in questo caso non \`e necessaria nessuna
operazione su $v_{2}$).

L'aggettivo \emph{Depth First} cattura l'idea che la ricerca procede
in profondit\`a, allontanandosi sempre pi\`u dal punto di partenza,
spostandosi da un vertice al un vicino di tale vertice, al vicino del
vicino di tale vertice e cos\`i via, tornando indietro solo quando si
raggiunge un vertice il cui vicinato \`e completamente esplorato,
oppure che tale vicinato sia vuoto.

\begin{paragraph}{maze problem solver}
  Papadimitriou, in \footnote{aggiungere qui riferimento bibliografico
    a Algorithms, pag 83}, vede questa ricerca come un algoritmo per
  risolvere un labirinto, identificandone le idee principali che
  abbiamo espresso in forma diversa nei precedenti paragrafi:
\begin{quotation}
  [...] the reachability problem is rather like exploring a
  labyrinth[...], a careless choice of passage might lead you around
  in circles or might cause you to return to passages that you
  previously saw but did not investigate.[...] Everybody knows that
  all you need to explore a labyrinth is a ball of string and a piece
  of chalk. The chalk prevents looping, the string always takes you
  back...
\end{quotation}
Riportando questa idea su quanto detto sopra, il concetto di vertice
\emph{esplorato} corrisponde al \emph{chalk}, mentre l'insieme di
vertici \emph{pi\`u recentemente esplorati} corrisponde a \emph{ball
  of string}.
\end{paragraph}

\subsection{Pseudocodice e complessit\`a}
Formalizziamo la visita \emph{visita in profondit\`a} nel seguente pseudo
codice:
\begin{lstlisting}
    procedure DFS(G = (V, E))
      for all v in V:
        visited(v) = false

      for all v in V:
        if not visitato(v):explore(v, E)

    procedure explore(v, E):
      visitato(v) = vero
      previsita(v)
      for each arco (v, u) in E:
        se non visitato(u): explore(u)
      postvisita(v)
\end{lstlisting}

Facciamo una breve analisi della complessit\`a. La prima osservazione
da fare \`e che ogni vertice viene esaminato una e una sola volta
grazie al vettore \emph{visitato}. Durante l'esplorazione di un vertice
si spende una quantit\`a costante per settare il vertice come visitato
e per le due invocazioni delle funzioni \emph{previsita,
  postvisita}. Per quanto riguarda invece la scansione del vicinato,
abbiamo per ogni vertice un tempo impiegato diverso, per questo motivo
consideriamo l'intero insieme di archi in una sola volta. Ogni arco
verr\`a visitato una e una sola nel caso in cui il grafo in input sia
orientato, altrimenti due volte nel caso in cui il grafo in input sia
non orientato. Segue che il tempo impiegato dalla visita \`e $O(|V| +
|E|)$, lineare nella lunghezza dell'input.

\subsection{Introducing hot-spots for extendibility}
\`E possibile "personalizzare" lo schema classico della ricerca
\emph{visita in profondit\`a} in modo da inserire degli \emph{hot-spots}
che permettano di eseguire del comportamento dedicato all'avvenire di
eventi salienti durante la visita. Nello schema che abbiamo riportato
ne abbiamo inseriti due: le funzioni \emph{previsita} e
\emph{postvisita}. Vediamo alcuni usi.

Se il grafo in input $G$ \`e un albero allora se utilizziamo solo
$previsita$ il risultato \`e equivalente ad una visita \emph{prefissa}
dell'albero, mentre se utilizziamo solo \emph{postvisita} otteniamo una
visita \emph{postfissa} dell'albero.

Come vedremo nella sezione \ref{subsection:kosaraju-algorithm}, un
altro utilizzo \`e quello di associare ad ogni vertice una coppia di
istanti che indicano l'intervallo di tempo che il vertice rimane nella
pila, mentre si esplorano i vertici da questo raggiungibili.

\section{Algoritmi per la ricerca di componenti fortemente connesse}

In questa sezione faremo una panoramica sugli algoritmi pi\`u
conosciuti in letteratura per la ricerca di componenti fortemente
connesse di un grafo orientato. Ognuno dei seguenti algoritmi sono in
realt\`a delle varianti della \emph{visita in profondit\`a},
introducendo delle personalizzazioni allo schema visto nella sezione
precedente \footnote{per ognuno dei seguenti algoritmi riportare i
  riferimenti bibliografici.}

\subsection{Kosaraju: focus on sink components and reverse the input
  graph}
\label{subsection:kosaraju-algorithm}
Questa idea non introduce nessuna modifica allo schema che abbiamo
visto, bens\`i utilizza la procedura due volte (\emph{two phases}) su
grafi di input differenti.

Una osservazione che possiamo fare sullo schema classico \`e che
l'invocazione della procedura \emph{explore} invocata con input il
nodo $u$ termina quando tutti i nodi raggiungibili da $u$ sono stati
esplorati.

Da questo possiamo iniziare a ragionare in questo modo:
\begin{quotation}
  Supponiamo di conoscere la decomposizione in componenti fortemente
  connesse di un grafo: sia $C_{i}$ una di queste tale che sia pozzo
  (ovvero che non ha archi uscenti nel \emph{meta grafo} che ha come
  nodi le componenti fortemente connesse di cui stiamo ipotizzando
  l'esistenza) e sia $v$ un vertice tale che $v \in C_{i}$. Allora
  $C_{i} = explore(v)$ (per brevit\`a supponiamo che \emph{explore}
  ritorni l'insieme di nodi raggiungibili da $v$).\footnote{aggiungere
    la definizione di meta grafo nella parte di introduzione di questo
    capitolo dove si introduce un po di terminologia}
\end{quotation}

Con la precedente osservazione abbiamo un metodo per trovare una
componenti fortemente connesse, dobbiamo per\`o avere un modo per
trovare il vertice $v$ e cosa fare per trovare le altre componenti.

Prima di continuare, implementiamo le due funzioni \emph{previsita,
  postvisita} in modo da associare ad ogni vertice il momento in cui
viene esplorato e il momento in cui il suo vicinato viene
completamente esplorato, chiamiamo questo secondo istante \emph{post}
\footnote{aggiungere qui collegamento alle mia implementazione del dfs
  tree builder listener}.

Adesso che abbiamo definito la coppia di istanti possiamo osservare
che: 
\begin{quotation}
  il vertice tale che ha il pi\`u grande \emph{post} calcolato
  dall'invocazione di un \emph{visita in profondit\`a}, appartiene ad un
  componente fortemente connessa sorgente.
\end{quotation}

\`E facile individuare tali vertici, in quanto sono i nodi per i quali
la procedura \emph{DFS} invoca la procedura \emph{explore}. Per\`o
questo non \`e sufficiente per usare la precedente osservazione, in
quanto quello che si richiede \`e un vertice che appartenga ad una
componente fortemente connessa pozzo.

Per risolvere questo problema possiamo calcolare $G^{R}$
(\emph{reverse the graph!}). Notiamo che le componenti fortemente
connesse non cambiano la loro composizione in $G^{R}$ in quanto
consideriamo il sotto grafo di $G$ composto da una di queste: per
definizione di componente fortemente connessa, per ogni coppia di
vertici $(v_{1}, v_{2})$ esiste un cammino $c_{1} =
v_{1}\rightarrow^{*} v_{2}$ ed un camino $c_{2} = v_{2}\rightarrow^{*}
v_{1}$. Invertendo la direzione degli archi, i due cammini continuano
ad esistere (ovvero $c_{1}$ gioca il ruolo di $c_{2}$ e viceversa) e
quindi la relazione di connessione forte \`e chiusa rispetto alla
operazione $\cdot ^{R}$.

Il vantaggio di passare a $G^{R}$ \`e che le componenti fortemente
connesse sorgenti in $G$ diventano pozzi in $G^{R}$. Adesso possiamo
eseguire una \emph{visita in profondit\`a} su $G^{R}$ e, per la
seconda osservazione in quota, il vertice con associato il massimo
\emph{post} appartiene ad una componente fortemente connessa sorgente in
$G^{R}$ e, di conseguenza, ad una componente fortemente connessa pozzo
in $G$, che \`e quello che volevamo.

Quello che adesso rimane da fare \`e lanciare una \emph{Depth First
  Search} sul grafo di input $G$, scansionando i vertici in ordine
decrescente di \emph{post}. In questo modo tutte le componenti
fortemente connesse verranno identificate una alla volta per la prima
osservazione in quota. I vertici esplorati durante ogni invocazione
della procedura \emph{explore} eseguita dalla procedura \emph{DFS} \`e
una componente fortemente connessa del grafo $G$.

Questo algoritmo lavora in tempo lineare, richiedendo circa il doppio
del tempo richiesto dallo schema \emph{visita in profondit\`a} classico.

\subsection{Tarjan: numbering and \emph{LOWLINK}}
\label{subsection:tarjan-algorithm}
Questo algoritmo \`e stato il primo algoritmo per la ricerca delle
componenti fortemente connesse ad operare in tempo lineare.

La caratteristica di questo algoritmo \`e quella di modificare lo
schema di una \emph{visita in profondit\`a} classica, implementando i due
\emph{hot-spots} definiti nello pseudo codice ed aggiungere della
logica sia dopo aver terminato l'invocazione ricorsiva su ogni vertice
del vicinato non ancora esplorati, sia nel caso si incontrino vertici
gi\`a conosciuti.

I mattoncini utilizzati da questa variante sono:
\begin{description}
\item[numero funzione] associa ad ogni vertice un intero che
  rappresenta il momento in cui viene esplorato
\item[lowlink funzione] associa ad vertice un intero che rappresenta
  il vertice antenato $v$ con minor \emph{numero(v)}
\item[a pila] che contiene tutti i vertici che sono stati esplorati
  durante l'algoritmo ma che ancora non sono stati associati ad una
  componente fortemente connessa.
\end{description}

Inoltre Tarjan classifica gli archi del grafo in input dopo aver
applicato una \emph{visita in profondit\`a} in questo modo: 
\begin{description}
\item[tree edges] sono tutti quelli archi che hanno portato
  l'esplorazione di un nuovo vertice e sono presenti negli alberi
  \emph{DFS}. Questi archi sono indicati con $\rightarrow$
\item[forward edges] sono tutti quegli archi che non appartengono a
  nessun albero \emph{DFS}, che collegano un antenato ad un suo
  discendente
\item[back edges] sono tutti quegli archi che non appartengono a
  nessun albero \emph{DFS}, che collegano un discendente ad un suo
  antenato. Questi archi sono indicati con $\cdot\rightarrow$
\item[cross edges] sono tutti quegli archi che non appartengono a
  nessun albero \emph{DFS}, che collegano due vertici appartenenti a
  sottoalberi differenti (questi sotto alberi posso appartenere sia
  allo stesso albero \emph{DFS}, sia a due alberi \emph{DFS}
  disgiunti. Questi archi sono indicati con $\cdot\rightarrow$
\end{description}

Una osservazione da fare riguardo ai \emph{cross edge} \`e la
seguente. Sia $(v, w) \in E$ \`e un \emph{cross edge} allora
$numero(w) < numero(v)$ ovvero, graficamente parlando, i \emph{cross
  edge} hanno una unica direzione: da destra verso sinistra. Motivare
questo non \`e difficile in quanto se uno di tali archi avesse
direzione opposta, allora o verrebbe inserito nell'albero \emph{DFS}
(e quindi sarebbe un \emph{tree arco}, una contraddizione) oppure
raggiungerebbe un vertice gi\`a visitato (e quindi sarebbe un
\emph{in avanti arco}, un'altra contraddizione).

Vediamo adesso le idee principali alla base dell'algoritmo. La prima
di queste \`e la seguente:
\begin{quotation}
  Sia $C$ una componente fortemente connessa e due vertici $v, w \in
  C$. Sia $F$ l'insieme di alberi \emph{DFS} generati dall'esecuzione
  di una \emph{visita in profondit\`a}. Allora $v, w$ hanno un antenato
  comune nella foresta $F$ e, se identifichiamo con $u$ l' antenato
  tale che $numero(u)$ sia massimo tra tutti gli altri antenati comuni
  (ovvero quello pi\`u vicino ai due vertici), allora $u \in C$
\end{quotation}
Per far vedere la precedente osservazione supponiamo che durante una
\emph{visita in profondit\`a} il vertice $v$ sia visitato prima di $w$ (e
quindi $numero(v) < numero(w)$) e, dato che $v,w$ appartengono alla
stessa componente fortemente connessa, esiste un cammino $\pi$ tale che
$v \rightarrow^{*} w$ (e anche un cammino $w \rightarrow^{*} v$ per la
connettivit\`a forte). Chiamiamo $T_{u}$ il pi\`u piccolo albero che
ha come radice $u$ e che contiene tutti i vertici attraversati dal
cammino $\pi$. Il sotto albero $T_{u}$ esiste in quanto il cammino
$\pi$ pu\`o attraversare alberi della foresta $F$ i cui vertici hanno
associato un \emph{numero} minore (percorrendo \emph{cross archi}),
mentre non attraverser\`a alberi con numerazioni maggiori. Osserviamo
per\`o che se il cammino $\pi$ attraversasse pi\`u di un albero non
potr\`a arrivare in $w$ (ricordiamo che $\pi$ inizia in $v$)
contraddicendo l'ipotesi iniziale che $numero(v) < numero(w)$. Quindi
il sotto albero $T_{u}$ esiste e $v,w$ hanno un comune antenato, ma
dato che $T_{u}$ contiene tutti i vertici attraversati da $\pi$, anche
$u$ viene attraversato e quindi appartiene alla stessa componente
fortemente connessa.
\\\\
Adesso possiamo affrontare la seconda idea che ci dar\`a un modo per
identificare le componenti fortemente connesse:
\begin{quotation}
  Sia $C$ una componente fortemente connessa. Allora i vertici $v_{i}
  \in C$ appartengono ad uno stesso sotto albero nella foresta
  \emph{DFS}. Inoltre la radice del sotto albero viene chiamata la
  \emph{root} della componente fortemente connessa $C$
\end{quotation}
la precedente idea fa si che il problema di individuare le componenti
fortemente connesse si riduce ad identificare i vertici \emph{root} di
sotto alberi della foresta. Tarjan propone il seguente criterio per
individuare tali vertici:
\begin{quotation}
  un vertice $v$ \`e \emph{root} di una componente fortemente connessa
  se e solo se $numero(v) = LOWLINK(v)$ 
\end{quotation}
quanto detto in quota ha bisogno di alcune spiegazioni. La prima cosa
che dobbiamo definire \`e come calcolare $LOWLINK(v)$:
\begin{displaymath}
  \begin{split}
    LOWLINK(v) &= \min\{\{numero(v)\}, \\
    & \{numero(w): (\exists r \in V: v \rightarrow r \cdot\rightarrow w) \\
    & \wedge (\exists u \in V: u \rightarrow^{*} v \wedge u
    \rightarrow^{*} w \wedge \\
    & u,w \in C, \text{ for some componente fortemente connessa C}) \}\}
  \end{split}
\end{displaymath}
Pu\`o sembrare un po criptico ma non cattura un concetto difficile. Il
valore che la funzione $LOWLINK$ associa ad un vertice $v$ \`e il
minimo valore associato ad un vertice $v'$ appartenente alla stessa
componente fortemente connessa di $v$, attraversando un numero qualsiasi
di \emph{tree archi} seguito da un \emph{all'indietro arco}.

Pertanto un vertice \`e la \emph{root} di una componente fortemente connessa solo quando il valore associato dalla funzione $LOWLINK$ \`e
$numero(v)$ stesso, ovvero da $v$ non \`e possibile ne arrivare in
sottoalberi a sinistra (in quanto per questi sono gi\`a state
computate le componenti fortemente connesse), ne raggiungere un
antenato (altrimenti non sarebbe la \emph{root} della strongly
connected component).
\\\\
Questo algoritmo lavora in tempo polinomiale in quanto il tempo per
calcolare la funzione $LOWLINK$ \`e costante ed ogni vertice viene
inserito nello pila dei vertici da assegnare ad una strongly
connected component una e una sola volta. Inoltre, per verificare se
un vertice \`e contenuto nello pila possiamo utilizzare un vettore di
valori booleani, che rende questa operazione lineare.

\subsection{Crescenzi-Gambosi-Grossi variant: use two stacks}
\label{subsection:crescenzi-gambosi-grossi}
Anche questa variante personalizza lo schema classico di una
\emph{visita in profondit\`a}, utilizzando gli stessi \emph{hot-spot}
della versione di Tarjan descritta in
\ref{subsection:tarjan-algorithm}. 

Desriveremo questa variante in questa sezione facendo spesso paragoni
sui punti che possono avvicinare queste idee con quelle usate nella
versione di Tarjan, in quanto possiamo dire che queste due varianti si
"mimano" a vicenda.
\\\\
Questa variante classifica i vertici in due insiemi:
\begin{description}
\item[completi] quelli che sono stati completamente esplorati \emph{e}
  assegnati ad una componente fortemente connessa
\item[parziali] sono tutti quei vertici che appartengono ad un cammino
  relativo ad una esecuzione della visita, di cui alcuni possono
  essere completamente esplorati, ma che ancora non sono stati
  associati a nessuna componente fortemente connessa
\end{description}
In base a questa classificazione, possiamo indurne una anche sulle
componenti fortemente connesse, avendo rispettivamente delle
componenti \emph{complete}, \emph{parziali} oppure \emph{ignote}.

Questa classificazione dei vertici viene mantenuta in modo esplicito
(usando un funzione che associa ad ogni vertice un valore booleano),
mentre lo stesso concetto esiste, sotto mentite spoglie, nella
versione di Tarjan, calcolandolo come segue: se $LOWLINK(v) <
numero(v)$ e $v$ \`e nello pila allora $v$ \`e parziale, altrimenti
\`e completo.
\\\\
Un altro concetto in comune con la variante di Tarjan \`e quello di
\emph{rappresentante} di una componente fortemente connessa. Un
vertice $v$ si dice \emph{rappresentante} della propria componente
fortemente connessa se \`e il primo vertice della componente
fortemente connessa ad esser stato visitato. Il lettore noter\`a
subito che \`e possibile mappare questo concetto al \emph{root} di una
componente fortemente connessa utilizzato nella variante di Tarjan.

Una osservazione \`e necessaria riguardo ai rappresentanti:
\begin{quotation}
  quando una componente fortemente connessa diviene \emph{completa},
  tutti i vertici in essa contenuti sono a loro volta \emph{completi}
  e i vertici che sono dei \emph{rappresentanti} perdono tale ruolo.
\end{quotation}
questo implica che se un vertice ha il ruolo di \emph{rappresentante}
allora appartiene ad una componente parziale. 

Inoltre i vertici \emph{rappresentanti} permettono di distinguere
l'inizio di una componente fortemente connessa dalla successiva e, come
vedremo, vengono numerati in ordine crescente rispetto al momento in
cui vengono esplorati (anche questo concetto lo si ritrova nella
variante di Tarjan dove si utilizza la funzione $numero$).
\\\\
La variante di Crescenzi-Gambosi-Grossi, a regime, mantiene due pila,
uno per mantenere l'insieme dei vertici \emph{parziali}, l'altro per
mantenere l'insieme dei vertici \emph{rappresentanti}. Tutti i vertici
che appartengo alla stessa componente fortemente connessa occupano
posizioni contigue nel relativo pila mentre il primo di essi sar\`a
inserito anche nello pila dei \emph{rappresentanti} finch\`e la
componente fortemente connessa non viene chiusa.

L'algoritmo che implementa questa variante procede seguendo la
seguente idea:
\begin{quotation}
  ogni volta che un nuovo vertice viene esplorato, inseriamolo nei due
  pila ed esploriamo il suo vicinato. Per i vertici non esplorati
  invochiamo ricorsivamente la visita, per quelli gi\`a incontrati
  chiediamo: se non sono completi allora si estrae dallo pila dei
  \emph{rappresentanti}
\end{quotation}
queste semplici regole necessitano di qualche
spiegazione. 

Inizialmente ogni nuovo vertice che viene esplorato viene
inserito in entrambi gli pila in quanto potrebbe iniziare una nuova
componente fortemente connessa, di cui il vertice sarebbe il
\emph{rappresentante}. 

L'altro punto da chiarire \`e quando si debbono estrarre i vertici
dallo pila dei \emph{rappresentanti}. Se, scandendo il vicinato,
esiste un vertice gi\`a esplorato e questo non \`e \emph{completo}
significa che l'arco che porta in questo vertice porta un ciclo e
quindi, non pu\`o essere un \emph{rappresentante}. Se invece tale
vertice fosse \emph{completo} allora gi\`a appartiene ad una strongly
connected component, e l'arco che porta a questo \`e quello che nella
variante di Tarjan viene classificato come \emph{cross link}.

Nello pila dei rappresentanti saranno presenti solo i vertici che non
hanno \emph{all'indietro archi} e, come nella variante di Tarjan, si
costruisce una componente fortemente connessa quando un vertice, dopo
aver esplorato tutto il suo vicinato, si trova in testa allo pila dei
\emph{rappresentanti}. La nuova componente fortemente connessa sar\`a
composta da tutti i vertici contenuti nello pila dei \emph{parziali}
contenuti tra la cima dello pila e la posizione del rappresentante
compresa. Ognuno di loro viene marcato come \emph{completo} e si
continua l'eventuale computazione.
\\\\
Anche per questa variante il tempo richiesto \`e lineare: ogni vertice
viene inserito ed estratto al pi\`u una volta in ogni pila (il caso
degenere \`e un grafo i cui vertici sono tutti isolati, per cui ogni
vertice corrisponde ad una componente fortemente connessa), non
aggiungendo asintoticamente niente al tempo richiesto dalla
\emph{visita in profondit\`a}.




