\section{"Telling stories" characterization}


\section{DFS search}

La ricerca (o visita) di un grafo \`e una procedura che rivela molte
informazioni sulla sua struttura e molte implementazioni richiedono
tempo lineare.

Prima di descrivere in particolare la ricerca oggetto di questa
sezione, diamo una breve descrizione del problema pi\`u generico,
ovvero di cosa significa visitare un grafo. 

\subsection{The search concept}

Sia $G$ il grafo che vogliamo visitare. Inizialmente tutti i vertici
che compongono il grafo sono sconosciuti, nessuno di essi \`e stato
\emph{esplorato}. Iniziamo da un vertice e seguiamo uno dei suoi
archi, che porter\`a ad un nuovo vertice. Continuiamo ad applicare
questa tecnica: quando arriviamo ad un vertice selezioniamo un arco
non ancora percorso, uscente da vertici gi\`a conosciuti. Percorrendo
l'arco che volta volta viene selezionato, si arriva in un vertice che
possiamo aver gi\`a visitato oppure no. Quando non \`e possibile
selezionare nessun arco non ancora percorso uscente da vertici gi\`a
visitati, allora si seleziona un vertice non ancora selezionato e si
riapplica la tecnica descritta precedentemente.

Come si capisce dal paragrafo precedente, la visita mira ad
identificare un insieme di vertici del grafo a partire da un vertice
dato in cui la visita ha inizio.

\subsection{\emph{Depth First} strategy as maze solver}
Nella precedente sezione abbiamo dato l'idea alla base di una
visita. Vi sono molte strategie che differenziano una visita
dall'altra, ognuna caratterizzata dalla modalit\`a con cui si sceglie
il prossimo arco da percorrere.

La ricerca \emph{Depth First Search} \`e caratterizzata dalla seguente
strategia: \emph{nella selezione del prossimo arco da percorrere,
  scegliere un arco uscente non ancora percorso dal vertice pi\`u
  recentemente esplorato}.

L'insieme dei vertici \emph{pi\`u recentemente esplorati} pu\`o essere
mantenuto in uno \emph{stack}.

Per capire meglio il pattern di questa tecnica supponiamo di iniziare
la visita dal vertice $v$. Prima $v$ viene visitato, poi il suo primo
vicino $v_{1}$ viene scelto e si percorre l'arco $(v, v_{1})$. Adesso
$v_{1}$ viene visitato e si riapplica lo stesso metodo al vicinato di
$v_{1}$. Solo quando tutti i vertici nel vicinato di $v_{1}$ sono
visitati \`e possibile continuare ad esplorare il secondo vicino
$v_{2}$ di $v$ (\`e possibile che $v_{2}$ venga visitato durante
l'esplorazione di $v_{1}$, in questo caso non \`e necessaria nessuna
operazione su $v_{2}$).

L'aggettivo \emph{Depth First} cattura l'idea che la ricerca procede
in profondit\`a, allontanandosi sempre pi\`u dal punto di partenza,
spostandosi da un vertice al un vicino di tale vertice, al vicino del
vicino di tale vertice e cos\`i via, tornando indietro solo quando si
raggiunge un vertice il cui vicinato \`e completamente esplorato,
oppure che tale vicinato sia vuoto.

\begin{paragraph}{maze problem solver}
  Papadimitriou, in \footnote{aggiungere qui riferimento bibliografico
    a Algorithms, pag 83}, vede questa ricerca come un algoritmo per
  risolvere un labirinto, identificandone le idee principali che
  abbbiamo espresso in forma diversa nei precedenti paragrafi:
\begin{quotation}
  [...] the reachability problem is rather like exploring a
  labyrinth[...], a careless choice of passage might lead you around
  in circles or might cause you to return to passages that you
  previously saw but did not investigate.[...] Everybody knows that
  all you need to explore a labyrinth is a ball of string and a piece
  of chalk. The chalk prevents looping, the string always takes you
  back...
\end{quotation}
Riportando questa idea su quanto detto sopra, il concetto di vertice
\emph{esplorato} corrisponde al \emph{chalk}, mentre l'insieme di
vertici \emph{pi\`u recentemente esplorati} corrisponde a \emph{ball
  of string}.
\end{paragraph}

\subsection{Pseudocode and complexity}
Formalizziamo la visita \emph{Depth First Search} nel seguente pseudo
codice:
\begin{lstlisting}
    procedure DFS(G = (V, E))
      for all v in V:
        visited(v) = false

      for all v in V:
        if not visited(v):explore(v, E)

    procedure explore(v, E):
      visited(v) = true
      previsit(v)
      for each edge (v, u) in E:
        if not visited(u): explore(u)
      postvisit(v)
\end{lstlisting}

Facciamo una breve analisi della complessit\`a. La prima osservazione
da fare \`e che ogni vertice viene esaminato una e una sola volta
grazie all'array \emph{visited}. Durante l'esplorazione di un vertice
si spende una quantit\`a costante per settare il vertice come visitato
e per le due invocazioni delle funzioni \emph{previsit,
  postvisit}. Per quanto riguarda invece la scansione del vicinato,
abbiamo per ogni vertice un tempo impiegato diverso, per questo motivo
consideriamo l'intero insieme di archi in una sola volta. Ogni arco
verr\`a visitato una e una sola nel caso in cui il grafo in input sia
orientato, altrimenti due volte nel caso in cui il grafo in input sia
non orientato. Segue che il tempo impiegato dalla visita \`e $O(|V| +
|E|)$, lineare nella lunghezza dell'input.

\subsection{Introducing hot-spots for extendibility}
\`E possibile "templetizzare" lo schema classico della ricerca
\emph{Depth First Search} in modo da inserire degli \emph{hot-spots}
che permettano di eseguire del comportamento dedicato all'avvenire di
eventi salienti durante la visita. Nello schema che abbiamo riportato
ne abbiamo inseriti due: le funzioni \emph{previsit} e
\emph{postvisit}. Vediamo alcuni usi.

Se il grafo in input $G$ \`e un albero allora se utilizziamo solo
$previsit$ il risultato \`e equivalente ad una visita \emph{prefissa}
dell'albero, mentre se utilizziamo solo \emph{postvisit} otteniamo una
visita \emph{postfissa} dell'albero.

Come vedremo nella sezione \ref{subsection:kosaraju-algorithm}, un
altro utilizzo \`e quello di associare ad ogni vertice una coppia di
istanti che indicano l'intervallo di tempo che il vertice rimane nella
pila, mentre si esplorano i vertici da questo raggiungibili.

TODO\footnote{aggiungere qui un paragrafetto sulla possibilit\`a di
  risolvere il problema delle otto regine, prendere questa parte dal
  libro che ho scaricato l'altro giorno sui grafi, dovrebbe essere il
  primo della cartella.}

\section{Finding strongly connected components: a survey of
  algorithms}

In questa sezione faremo una panoramica sugli algoritmi pi\`u
conosciuti in letteratura per la ricerca di strongly connected
components di un grafo orientato. Ognuno dei seguenti algoritmi sono
in realt\`a delle varianti della \emph{Depth First Search},
introducendo delle personalizzazioni allo schema visto nella sezione
precedente \footnote{per ognuno dei seguenti algoritmi riportare i
  riferimenti bibliografici.}

\subsection{Kosaraju: focus on sink components and reverse the input
  graph}
\label{subsection:kosaraju-algorithm}
Questa idea non introduce nessuna modifica allo schema che abbiamo
visto, bens\`i utilizza la procedura due volte (\emph{two phases}) su
grafi di input differenti.

Una osservazione che possiamo fare sullo schema classico \`e che
l'invocazione della procedura \emph{explore} invocata con input il
nodo $u$ termina quando tutti i nodi raggiungibili da $u$ sono stati
esplorati.

Da questo possiamo iniziare a ragionare in questo modo:
\begin{quotation}
  Supponiamo di conoscere la decomposizione in strongly connected
  components di un grafo: sia $C_{i}$ una di queste tale che sia pozzo
  (ovvero che non ha archi uscenti nel \emph{meta grafo} che ha come
  nodi le strongly connected components di cui stiamo ipotizzando
  l'esistenza) e sia $v$ un vertice tale che $v \in C_{i}$. Allora
  $C_{i} = explore(v)$ (per brevit\`a supponiamo che \emph{explore}
  ritorni l'insieme di nodi raggiungibili da $v$).\footnote{aggiungere
    la definizione di meta grafo nella parte di introduzione di questo
    capitolo dove si introduce un po di terminologia}
\end{quotation}

Con la precedente osservazione abbiamo un metodo per trovare una
strongly connected components, dobbiamo per\`o avere un modo per
trovare il vertice $v$ e cosa fare per trovare le altre componenti.

Prima di continuare, implementiamo le due funzioni \emph{previsit,
  postvisit} in modo da associare ad ogni vertice il momento in cui
viene esplorato e il momento in cui il suo vicinato viene
completamente esplorato, chiamiamo questo secondo istante \emph{post}
\footnote{aggiungere qui collegamento alle mia implementazione del dfs
  tree builder listener}.

Adesso che abbiamo definito la coppia di istanti possiamo osservare
che: 
\begin{quotation}
  il vertice tale che ha il pi\`u grande \emph{post} calcolato
  dall'invocazione di un \emph{Depth First Search}, appartiene ad un
  strongly connected component sorgente.
\end{quotation}

\`E facile individuare tali vertici, in quanto sono i nodi per i quali
la procedura \emph{DFS} invoca la procedura \emph{explore}. Per\`o
questo non \`e sufficiente per usare la precedente osservazione, in
quanto quello che si richiede \`e un vertice che appartenga ad una
strongly connected component pozzo.

Per risolvere questo problema possiamo calcolare $G^{R}$
(\emph{reverse the graph!}). Notiamo che le strongly connected
components non cambiano la loro composizione in $G^{R}$ in quanto
consideriamo il sottografo di $G$ composto da una di queste: per
definizione di strongly connected component, per ogni coppia di
vertici $(v_{1}, v_{2})$ esiste un cammino $c_{1} =
v_{1}\rightarrow^{*} v_{2}$ ed un camino $c_{2} = v_{2}\rightarrow^{*}
v_{1}$. Invertendo la direzione degli archi, i due cammini continuano
ad esistere (ovvero $c_{1}$ gioca il ruolo di $c_{2}$ e viceverca) e
quindi la relazione di connessione forte \`e chiusa rispetto alla
operazione $\cdot ^{R}$.

Il vantaggio di passare a $G^{R}$ \`e che le strongly connected
components sorgenti in $G$ diventano pozzi in $G^{R}$. Adesso possiamo
eseguire una \emph{Depth First Search} su $G^{R}$ e, per la seconda
osservazione in quota, il vertice con associato il massimo \emph{post}
appartiene ad una strongly connected component sorgente in $G^{R}$ e,
di conseguenza, ad una strongly connected component pozzo in $G$, che
\`e quello che volevamo.

Quello che adesso rimane da fare \`e lanciare una \emph{Depth First
  Search} sul grafo di input $G$, scansionando i vertici in ordine
decrescente di \emph{post}. In questo modo tutte le strongly connected
components verranno identificate una alla volta per la prima
osservazione in quota. I vertici esplorati durante ogni invocazione
della procedura \emph{explore} eseguita dalla procedura \emph{DFS} \`e
una strongly connected component del grafo $G$.

Questo algoritmo lavora in tempo lineare, richiedendo circa il doppio
del tempo richiesto dallo schema \emph{Depth First Search} classico.

\subsection{Tarjan: numbering and \emph{LOWLINK}}
\label{subsection:tarjan-algorithm}
Questo algoritmo \`e stato il primo algoritmo per la ricerca delle
strongly connected components ad operare in tempo lineare.

La caratteristica di questo algoritmo \`e quella di modificare lo
schema di una \emph{Depth First Search} classica, implementando i due
\emph{hot-spots} definiti nello pseudo codice ed aggiungere della
logica sia dopo aver terminato l'invocazione ricorsiva su ogni vertice
del vicinato non ancora esplorati, sia nel caso si incontrino vertici
gi\`a conosciuti.

I mattoncini utilizzati da questa variante sono:
\begin{description}
\item[number function] associa ad ogni vertice un intero che
  rappresenta il momento in cui viene esplorato
\item[lowlink function] associa ad vertice un intero che rappresenta
  il vertice antenato $v$ con minor \emph{number(v)}
\item[a stack] che contiene tutti i vertici che sono stati esplorati
  durante l'algoritmo ma che ancora non sono stati associati ad una
  componente fortemente connessa.
\end{description}

Inoltre Tarjan classifica gli archi del grafo in input dopo aver
applicato una \emph{Depth First Search} in questo modo: 
\begin{description}
\item[tree edges] sono tutti queli archi che hanno portato
  l'esplorazione di un nuovo vertice e sono presenti negli alberi
  \emph{DFS}. Questi archi sono indicati con $\rightarrow$
\item[forward edges] sono tutti quegli archi che non appartengono a
  nessun albero \emph{DFS}, che collegano un antenato ad un suo
  discendente
\item[back edges] sono tutti quegli archi che non appartengono a
  nessun albero \emph{DFS}, che collegano un discendente ad un suo
  antenato. Questi archi sono indicati con $\cdot\rightarrow$
\item[cross edges] sono tutti quegli archi che non appartengono a
  nessun albero \emph{DFS}, che collegano due vertici appartenenti a
  sottoalberi differenti (questi sotto alberi posso appartenere sia
  allo stesso albero \emph{DFS}, sia a due alberi \emph{DFS}
  disgiunti. Questi archi sono indicati con $\cdot\rightarrow$
\end{description}

Una osservazione da fare riguardo ai \emph{cross edge} \`e la
seguente. Sia $(v, w) \in E$ \`e un \emph{cross edge} allora
$number(w) < number(v)$ ovvero, graficamente parlando, i \emph{cross
  edge} hanno una unica direzione: da destra verso sinistra. Motivare
questo non \`e difficile in quanto se uno di tali archi avesse
direzione opposta, allora o verrebbe inserito nell'albero \emph{DFS}
(e quindi sarebbe un \emph{tree edge}, una contraddizione) oppure
raggiungerebbe un vertice gi\`a visitato (e quindi sarebbe un
\emph{forward edge}, un'altra contraddizione).

Vediamo adesso le idee principali alla base dell'algoritmo. La prima
di queste \`e la seguente:
\begin{quotation}
  Sia $C$ una strongly connected component e due vertici $v, w \in
  C$. Sia $F$ l'insieme di alberi \emph{DFS} generati dall'esecuzione
  di una \emph{Depth First Search}. Allora $v, w$ hanno un antenato
  comune nella foresta $F$ e, se identifichiamo con $u$ l' antenato
  tale che $number(u)$ sia massimo tra tutti gli altri antenati comuni
  (ovvero quello pi\`u vicino ai due vertici), allora $u \in C$
\end{quotation}
Per far vedere la precedente osservazione supponiamo che durante una
\emph{Depth First Search} il vertice $v$ sia visitato prima di $w$ (e
quindi $number(v) < number(w)$) e, dato che $v,w$ appartengono alla
stessa strongly connected component, esiste un cammino $\pi$ tale che
$v \rightarrow^{*} w$ (e anche un cammino $w \rightarrow^{*} v$ per la
connettivit\`a forte). Chiamiamo $T_{u}$ il pi\`u piccolo albero che
ha come radice $u$ e che contiene tutti i vertici attraversati dal
cammino $\pi$. Il sottoalbero $T_{u}$ esiste in quanto il cammino
$\pi$ pu\`o attraversare alberi della foresta $F$ i cui vertici hanno
associato un \emph{number} minore (percorrendo \emph{cross edges}),
mentre non attraverser\`a alberi con numerazioni maggiori. Osserviamo
per\`o che se il cammino $\pi$ attraversasse pi\`u di un albero non
potr\`a arrivare in $w$ (ricordiamo che $\pi$ inizia in $v$)
contraddicendo l'ipotesi iniziale che $number(v) < number(w)$. Quindi
il sottoalbero $T_{u}$ esiste e $v,w$ hanno un comune antenato, ma
dato che $T_{u}$ contiene tutti i vertici attraversati da $\pi$, anche
$u$ viene attraversato e quindi appartiene alla stessa componente
fortemente connessa.
\\\\
Adesso possiamo affrontare la seconda idea che ci dar\`a un modo per
identificare le strongly connected components:
\begin{quotation}
  Sia $C$ una strongly connected component. Allora i vertici $v_{i}
  \in C$ appartengono ad uno stesso sottoalbero nella foresta
  \emph{DFS}. Inoltre la radice del sottoalbero viene chiamata la
  \emph{root} della strongly connected component $C$
\end{quotation}
la precedente idea fa si che il problema di individuare le strongly
connected components si riduce ad identificare i vertici \emph{root} di
sottoalberi della foresta. Tarjan propone il seguente criterio per
individuare tali vertici:
\begin{quotation}
  un vertice $v$ \`e \emph{root} di una strongly connected component
  se e solo se $number(v) = LOWLINK(v)$ 
\end{quotation}
quanto detto in quota ha bisogno di alcune spiegazioni. La prima cosa
che dobbiamo definire \`e come calcolare $LOWLINK(v)$:
\begin{displaymath}
  \begin{split}
    LOWLINK(v) &= \min\{\{number(v)\}, \\
    & \{number(w): (\exists r \in V: v \rightarrow r \cdot\rightarrow w) \\
    & \wedge (\exists u \in V: u \rightarrow^{*} v \wedge u
    \rightarrow^{*} w \wedge \\
    & u,w \in C, \text{ for some strongly connected component C}) \}\}
  \end{split}
\end{displaymath}
Pu\`o sembrare un po criptico ma non cattura un concetto difficile. Il
valore che la funzione $LOWLINK$ associa ad un vertice $v$ \`e il
minimo valore associato ad un vertice $v'$ appartenente alla stessa
strongly connected component di $v$, attraversando un numero qualsiasi
di \emph{tree edges} seguito da un \emph{back edge}.

Pertanto un vertice \`e la \emph{root} di una strongly connected
component solo quando il valore associato dalla funzione $LOWLINK$ \`e
$number(v)$ stesso, ovvero da $v$ non \`e possibile ne arrivare in
sottoalberi a sinistra (in quanto per questi sono gi\`a state
computate le strongly connected components), ne raggiungere un
antenato (altrimenti non sarebbe la \emph{root} della strongly
connected component).
\\\\
Questo algoritmo lavora in tempo polinomiale in quanto il tempo per
calcolare la funzione $LOWLINK$ \`e costante ed ogni vertice viene
inserito nello stack dei vertici da assegnare ad una strongly
connected component una e una sola volta. Inoltre, per verificare se
un vertice \`e contenuto nello stack possiamo utilizzare un vettore di
valori booleani, che rende questa operazione lineare.

\subsection{Crescenzi-Gambosi-Grossi: two stacks}
Anche questa variante personalizza lo schema classico di una
\emph{Depth First Search}, utilizzando gli stessi \emph{hot-spot}
della versione di Tarjan descritta in
\ref{subsection:tarjan-algorithm}. 

Desriveremo questa variante in questa sezione facendo spesso paragoni
sui punti che possono avvicinare queste idee con quelle usate nella
versione di Tarjan, in quanto possiamo dire che queste due varianti si
"mimano" a vicenda.
\\\\
Questa variante classifica i vertici in due insiemi:
\begin{description}
\item[completi] quelli che sono stati completamente esplorati \emph{e}
  assegnati ad una strongly connected component
\item[parziali] sono tutti quei vertici che appartengono ad un cammino
  relativo ad una esecuzione della visita, di cui alcuni possono
  essere completamente esplorati, ma che ancora non sono stati
  associati a nessuna strongly connected component
\end{description}
In base a questa classificazione, possiamo indurne una anche sulle
strongly connected components, avendo rispettivamente delle componenti
\emph{complete}, \emph{parziali} oppure \emph{ignote}.

Questa classificazione dei vertici viene mantenuta in modo esplicito
(usando un funzione che associa ad ogni vertice un valore booleano),
mentre lo stesso concetto esiste, sotto mentite spoglie, nella
versione di Tarjan, calcolandolo come segue: se $LOWLINK(v) <
number(v)$ e $v$ \`e nello stack allora $v$ \`e parziale, altrimenti
\`e completo.
\\\\
Un altro concetto in comune con la variante di Tarjan \`e quello di
\emph{rappresentante} di una strongly connected component. Un vertice
$v$ si dice \emph{rappresentante} della propria strongly connected
component se \`e il primo vertice della strongly connected component
ad esser stato visitato. Il lettore noter\`a subito che \`e possibile
mappare questo concetto al \emph{root} di una strongly connected
component utilizzato nella variante di Tarjan.

Una osservazione \`e necessaria riguardo ai rappresentanti:
\begin{quotation}
  quando una strongly connected component diviene \emph{completa},
  tutti i vertici in essa contenuti sono a loro volta \emph{completi}
  e i vertici che sono dei \emph{rappresentanti} perdono tale ruolo.
\end{quotation}
questo implica che se un vertice ha il ruolo di \emph{rappresentante}
allora appartiene ad una componente parziale. 

Inoltre i vertici \emph{rappresentanti} permettono di distinguere
l'inizio di una strongly connected component dalla successiva e, come
vedremo, vengono numerati in ordine crescente rispetto al momento in
cui vengono esplorati (anche questo concetto lo si ritrova nella
variante di Tarjan dove si utilizza la funzione $number$).
\\\\
La variante di Crescenzi-Gambosi-Grossi, a regime, mantiene due stack,
uno per mantenere l'insieme dei vertici \emph{parziali}, l'altro per
mantenere l'insieme dei vertici \emph{rappresentanti}. Tutti i vertici
che appartengo alla stessa strongly connected component occupano
posizioni contigue nel relativo stack mentre il primo di essi sar\`a
inserito anche nello stack dei \emph{rappresentanti} finch\`e la
strongly connected component non viene chiusa.

L'algoritmo che implementa questa variante procede seguendo la
seguente idea:
\begin{quotation}
  ogni volta che un nuovo vertice viene esplorato, inseriamolo nei due
  stack ed esploriamo il suo vicinato. Per i vertici non esplorati
  invochiamo ricorsivamente la visita, per quelli gi\`a incontrati
  chiediamo: se non sono completi allora si estrae dallo stack dei
  \emph{rappresentanti}
\end{quotation}
queste semplici regole necessitano di qualche
spiegazione. 

Inizialmente ogni nuovo vertice che viene esplorato viene
inserito in entrambi gli stack in quanto potrebbe iniziare una nuova
strongly connected component, di cui il vertice sarebbe il
\emph{rappresentante}. 

L'altro punto da chiarire \`e quando si debbono estrarre i vertici
dallo stack dei \emph{rappresentanti}. Se, scandendo il vicinato,
esiste un vertice gi\`a esplorato e questo non \`e \emph{completo}
significa che l'arco che porta in questo vertice porta un ciclo e
quindi, non pu\`o essere un \emph{rappresentante}. Se invece tale
vertice fosse \emph{completo} allora gi\`a appartiene ad una strongly
connected component, e l'arco che porta a questo \`e quello che nella
variante di Tarjan viene classificato come \emph{cross link}.

Nello stack dei rappresentanti saranno presenti solo i vertici che non
hanno \emph{back edges} e, come nella variante di Tarjan, si
costruisce una strongly connected component quando un vertice, dopo
aver esplorato tutto il suo vicinato, si trova in testa allo stack dei
\emph{rappresentanti}. La nuova strongly connected component sar\`a
composta da tutti i vertici contenuti nello stack dei \emph{parziali}
contenuti tra la cima dello stack e la posizione del rappresentante
compresa. Ognuno di loro viene marcato come \emph{completo} e si
continua l'eventuale computazione.
\\\\
Anche per questa variante il tempo richiesto \`e lineare: ogni vertice
viene inserito ed estratto al pi\`u una volta in ogni pila (il caso
degenere \`e un grafo i cui vertici sono tutti isolati, per cui ogni
vertice corrisponde ad una strongly connected component), non
aggiungendo asintoticamente niente al tempo richiesto dalla
\emph{Depth First Search}.
