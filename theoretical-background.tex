\section{"Telling stories" characterization}


\section{DFS search}

La ricerca (o visita) di un grafo \`e una procedura che rivela molte
informazioni sulla sua struttura e molte implementazioni richiedono
tempo lineare.

Prima di descrivere in particolare la ricerca oggetto di questa
sezione, diamo una breve descrizione del problema pi\`u generico,
ovvero di cosa significa visitare un grafo. 

\subsection{The search concept}

Sia $G$ il grafo che vogliamo visitare. Inizialmente tutti i vertici
che compongono il grafo sono sconosciuti, nessuno di essi \`e stato
\emph{esplorato}. Iniziamo da un vertice e seguiamo uno dei suoi
archi, che porter\`a ad un nuovo vertice. Continuiamo ad applicare
questa tecnica: quando arriviamo ad un vertice selezioniamo un arco
non ancora percorso, uscente da vertici gi\`a conosciuti. Percorrendo
l'arco che volta volta viene selezionato, si arriva in un vertice che
possiamo aver gi\`a visitato oppure no. Quando non \`e possibile
selezionare nessun arco non ancora percorso uscente da vertici gi\`a
visitati, allora si seleziona un vertice non ancora selezionato e si
riapplica la tecnica descritta precedentemente.

Come si capisce dal paragrafo precedente, la visita mira ad
identificare un insieme di vertici del grafo a partire da un vertice
dato in cui la visita ha inizio.

\subsection{\emph{Depth First} strategy as maze solver}
Nella precedente sezione abbiamo dato l'idea alla base di una
visita. Vi sono molte strategie che differenziano una visita
dall'altra, ognuna caratterizzata dalla modalit\`a con cui si sceglie
il prossimo arco da percorrere.

La ricerca \emph{Depth First Search} \`e caratterizzata dalla seguente
strategia: \emph{nella selezione del prossimo arco da percorrere,
  scegliere un arco uscente non ancora percorso dal vertice pi\`u
  recentemente esplorato}.

L'insieme dei vertici \emph{pi\`u recentemente esplorati} pu\`o essere
mantenuto in uno \emph{stack}.

Per capire meglio il pattern di questa tecnica supponiamo di iniziare
la visita dal vertice $v$. Prima $v$ viene visitato, poi il suo primo
vicino $v_{1}$ viene scelto e si percorre l'arco $(v, v_{1})$. Adesso
$v_{1}$ viene visitato e si riapplica lo stesso metodo al vicinato di
$v_{1}$. Solo quando tutti i vertici nel vicinato di $v_{1}$ sono
visitati \`e possibile continuare ad esplorare il secondo vicino
$v_{2}$ di $v$ (\`e possibile che $v_{2}$ venga visitato durante
l'esplorazione di $v_{1}$, in questo caso non \`e necessaria nessuna
operazione su $v_{2}$).

L'aggettivo \emph{Depth First} cattura l'idea che la ricerca procede
in profondit\`a, allontanandosi sempre pi\`u dal punto di partenza,
spostandosi da un vertice al un vicino di tale vertice, al vicino del
vicino di tale vertice e cos\`i via, tornando indietro solo quando si
raggiunge un vertice il cui vicinato \`e completamente esplorato,
oppure che tale vicinato sia vuoto.

\begin{paragraph}{maze problem solver}
  Papadimitriou, in \footnote{aggiungere qui riferimento bibliografico
    a Algorithms, pag 83}, vede questa ricerca come un algoritmo per
  risolvere un labirinto, identificandone le idee principali che
  abbbiamo espresso in forma diversa nei precedenti paragrafi:
\begin{quotation}
  [...] the reachability problem is rather like exploring a
  labyrinth[...], a careless choice of passage might lead you around
  in circles or might cause you to return to passages that you
  previously saw but did not investigate.[...] Everybody knows that
  all you need to explore a labyrinth is a ball of string and a piece
  of chalk. The chalk prevents looping, the string always takes you
  back...
\end{quotation}
Riportando questa idea su quanto detto sopra, il concetto di vertice
\emph{esplorato} corrisponde al \emph{chalk}, mentre l'insieme di
vertici \emph{pi\`u recentemente esplorati} corrisponde a \emph{ball
  of string}.
\end{paragraph}

\subsection{Pseudocode and complexity}
Formalizziamo la visita \emph{Depth First Search} nel seguente pseudo
codice:
\begin{lstlisting}
    procedure DFS(G = (V, E))
      for all v in V:
        visited(v) = false

      for all v in V:
        if not visited(v):explore(v, E)

    procedure explore(v, E):
      visited(v) = true
      previsit(v)
      for each edge (v, u) in E:
        if not visited(u): explore(u)
      postvisit(v)
\end{lstlisting}

Facciamo una breve analisi della complessit\`a. La prima osservazione
da fare \`e che ogni vertice viene esaminato una e una sola volta
grazie all'array \emph{visited}. Durante l'esplorazione di un vertice
si spende una quantit\`a costante per settare il vertice come visitato
e per le due invocazioni delle funzioni \emph{previsit,
  postvisit}. Per quanto riguarda invece la scansione del vicinato,
abbiamo per ogni vertice un tempo impiegato diverso, per questo motivo
consideriamo l'intero insieme di archi in una sola volta. Ogni arco
verr\`a visitato una e una sola nel caso in cui il grafo in input sia
orientato, altrimenti due volte nel caso in cui il grafo in input sia
non orientato. Segue che il tempo impiegato dalla visita \`e $O(|V| +
|E|)$, lineare nella lunghezza dell'input.

Un ultima osservazione sulle due operazioni \emph{previsit,
  postvisit}. Se il grafo in input $G$ \`e un albero allora se
utilizziamo solo $previsit$ il risultato \`e equivalente ad una visita
\emph{prefissa} dell'albero, mentre se utilizziamo solo
\emph{postvisit} otteniamo una visita \emph{postfissa} dell'albero.

\section{Finding strongly connected components: a survey of
  algorithms}

In questa sezione faremo una panoramica sugli algoritmi pi\`u
conosciuti in letteratura per la ricerca di componenti fortemente
connesse di un grafo orientato. Ognuno dei seguenti algoritmi sono in
realt\`a delle varianti della \emph{Depth First Search}, introducendo
delle personalizzazioni allo schema visto nella sezione precedente.

\subsection{Focus on sink components and reverse the input graph: the
  Kosaraju two phase algorithm}

Questa idea non introduce nessuna modifica allo schema che abbiamo
visto, bens\`i utilizza la procedura due volte (\emph{two phases}) su
grafi di input differenti.

Una osservazione che possiamo fare sullo schema classico \`e che
l'invocazione della procedura \emph{explore} invocata con input il
nodo $u$ termina quando tutti i nodi raggiungibili da $u$ sono stati
esplorati.

Da questo possiamo iniziare a ragionare in questo modo:
\begin{quotation}
  Supponiamo di conoscere la decomposizione in strongly connected
  components di un grafo: sia $C_{i}$ una di queste tale che sia pozzo
  (ovvero che non ha archi uscenti nel \emph{meta grafo} che ha come
  nodi le strongly connected components di cui stiamo ipotizzando
  l'esistenza) e sia $v$ un vertice tale che $v \in C_{i}$. Allora
  $C_{i} = explore(v)$ (per brevit\`a supponiamo che \emph{explore}
  ritorni l'insieme di nodi raggiungibili da $v$).\footnote{aggiungere
    la definizione di meta grafo nella parte di introduzione di questo
    capitolo dove si introduce un po di terminologia}
\end{quotation}

Con la precedente osservazione abbiamo un metodo per trovare una
strongly connected components, dobbiamo per\`o avere un modo per
trovare il vertice $v$ e cosa fare una volta trovata tale componente.

Prima di continuare, implementiamo le due funzioni \emph{previsit,
  postvisit} in modo da associare ad ogni vertice il momento in cui
viene esplorato e il momento in cui il suo vicinato viene
completamente esplorato, chiamiamo questo secondo istante \emph{post}.

Adesso che abbiamo definito la coppia di istanti possiamo osservare
che: 
\begin{quotation}
  il vertice tale che ha il pi\`u grande \emph{post} calcolato
  dall'invocazione di un \emph{Depth First Search}, appartiene ad un
  strongly connected component sorgente.
\end{quotation}

\`E facile individuare tali vertici, in quanto sono i nodi per i quali
la procedura \emph{DFS} invoca la procedura \emph{explore}. Per\`o
questo non \`e sufficiente per usare la precedente osservazione, in
quanto quello che si richiede \`e un vertice che appartenga ad una
strongly connected component pozzo.

Per risolvere questo problema possiamo calcolare $G^{R}$. Notiamo che
le strongly connected components non cambiano la loro composizione in
$G^{R}$ in quanto consideriamo il sottografo di $G$ composto da una di
queste: per definizione di strongly connected component, per ogni
coppia di vertici $(v_{1}, v_{2})$ esiste un cammino $c_{1} =
v_{1}\rightarrow^{*} v_{2}$ ed un camino $c_{2} = v_{2}\rightarrow^{*}
v_{1}$. Invertendo la direzione degli archi, i due cammini continuano
ad esistere (ovvero $c_{1}$ gioca il ruolo di $c_{2}$ e viceverca) e
quindi la relazione di connessione forte \`e chiusa rispetto alla
operazione $\cdot ^{R}$.

Il vantaggio di passare a $G^{R}$ \`e che le strongly connected
components sorgenti in $G$ diventano pozzi in $G^{R}$, che \`e quello
che volevamo. Adesso possiamo eseguire una \emph{Depth First Search}
su $G^{R}$ e, per la seconda osservazione in quota, il vertice con
associato il massimo \emph{post} appartiene ad una strongly connected
component sorgente in $G^{R}$ e, di conseguenza, ad una strongly connected
component pozzo in $G$.


