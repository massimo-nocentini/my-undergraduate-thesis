\section{Sviluppi futuri}

I seguenti punti possono essere presi come basi di partenza per
sviluppi futuri del progetto:
\begin{description}
\item[dependency injection] Rifattorizzare le parti del codice in cui
  vengono utilizzati degli oggetti \emph{factory} sostituendoli con
  motori di \emph{dependency injection}, applicando il principio di
  \emph{invertion of control};
\item[domain specific language] specificare e implementare un
  \emph{DSL} per poter descrivere e assemblare la pipeline in modo
  dichiarativo, senza dover scendere al livello delle interfacce e
  delle classi che abbiamo implementato. La definizione della pipeline
  potrebbe essere caricata da riga di comando oppure da un file
  esterno;
\item[graphviz interface] utilizzare una libreria che permette di
  usare programmaticamente gli oggetti e le implementazioni fornite
  dalla libreria \emph{graphviz}. Nell'attuale lavoro si utilizzano
  tali oggetti solo eseguendoli in modalit\`a di comando, equivalente
  ad una invocazione da terminale. Questo permetterebbe di avere un
  maggior grado di portabilit\`a del lavoro svolto, eliminando la
  dipendenza da una installazione a monte di \emph{graphviz};
\item[file di configurazione] creare un file di configurazione nel
  quale impostare quale motore di \emph{graphviz} utilizzare per la
  renderizzazione dei grafi (ad esempio esistono anche \emph{neato} e
  molti altri oltre a quello che abbiamo usato in questo lavoro), il
  preambolo dei documenti dot nei quali si specifica le formattazioni,
  i colori e le dimensioni di nodi e archi.

  Inoltre potrebbe essere interessante esprimere quanto detto nel
  precedente paragrafo con uno stesso DSL, in modo da poter codificare
  le proprie pipeline in batterie e lasciare al codice la
  responsabilit\`a di costruire i necessari oggetti ed eseguire le
  rispettive computazioni.

\item[rappresentare l'albero DFS nel grafo completo] costruire un
  nuovo filtro che permetta di comporre la funzionalit\`a per eseguire
  una visita in profondit\`a e rappresentare l'albero risultate
  ``sopra'' il grafo esistente. Per realizzarlo si potrebbe modificare
  la logica che implementa la visita eseguendola per un vertice scelto
  (oppure dato) e, successivamente, colorare gli archi del grafo che
  sono anche archi dell'albero \emph{DFS}, usando un colore pi\`u
  scuro (anche questo passo \`e gi\`a predisposto in quanto il colore
  grigio usato attualmente non \`e stato scelto a caso).


  % put here another further-work
\end{description}
